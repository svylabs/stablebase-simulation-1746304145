{"name": "Stablecoin and Staking Protocol", "summary": "StableBase is an over-collateralized borrowing protocol issuing DFID (D.FI.Dollar) tokens pegged to USD, managed via a Collateral Debt Position (CDP) system. It uses liquidations and redemptions to maintain stability, featuring 0% interest rates and origination fees, initially supporting only native ETH. A 'Pay As You Go' model protects against redemptions. DFIRE tokens reward Stability Pool contributors for one year; DFIRE stakers get 10% of fees, Stability Pool stakers 90%. The protocol includes DFIREToken staking and ChainlinkPriceOracle for price feeds, alongside a StabilityPool, OrderedDoublyLinkedList, and utility contracts for comprehensive DeFi functionality.", "type": "DeFi Protocol", "dev_tool": "hardhat", "contracts": [{"name": "StableBaseCDP", "type": "contract", "summary": "The StableBaseCDP contract manages Collateralized Debt Positions (CDPs) for a stablecoin system. Users can open, close, borrow against, repay, add/withdraw collateral from their Safes. The contract also includes functionality for liquidation, fee management, and token URI updates.", "functions": [{"name": "openSafe", "summary": "Opens a new Safe (Collateralized Debt Position) with a specified ID and collateral amount.", "inputs": ["uint256 _safeId", "uint256 _amount"], "outputs": []}, {"name": "closeSafe", "summary": "Closes an existing Safe, identified by its ID.", "inputs": ["uint256 safeId"], "outputs": []}, {"name": "borrow", "summary": "Borrows a specified amount against a Safe, considering parameters like shielding rate and queue positions.", "inputs": ["uint256 safeId", "uint256 amount", "uint256 shieldingRate", "uint256 nearestSpotInLiquidationQueue", "uint256 nearestSpotInRedemptionQueue"], "outputs": []}, {"name": "repay", "summary": "Repays a portion of the debt associated with a Safe.", "inputs": ["uint256 safeId", "uint256 amount", "uint256 nearestSpotInLiquidationQueue"], "outputs": []}, {"name": "addCollateral", "summary": "Adds collateral to an existing Safe.", "inputs": ["uint256 safeId", "uint256 amount", "uint256 nearestSpotInLiquidationQueue"], "outputs": []}, {"name": "withdrawCollateral", "summary": "Withdraws collateral from an existing Safe.", "inputs": ["uint256 safeId", "uint256 amount", "uint256 nearestSpotInLiquidationQueue"], "outputs": []}, {"name": "redeem", "summary": "Redeems a specified amount of the stablecoin, using the liquidation queue position.", "inputs": ["uint256 amount", "uint256 nearestSpotInLiquidationQueue"], "outputs": []}, {"name": "feeTopup", "summary": "Tops up the fees associated with a Safe, considering the redemption queue.", "inputs": ["uint256 safeId", "uint256 topupRate", "uint256 nearestSpotInRedemptionQueue"], "outputs": []}, {"name": "liquidate", "summary": "Initiates the liquidation process.", "inputs": [], "outputs": []}, {"name": "liquidateSafe", "summary": "Liquidates a specific Safe.", "inputs": ["uint256 safeId"], "outputs": []}, {"name": "adjustPosition", "summary": "Adjusts the position of a Safe, potentially related to its risk profile.", "inputs": ["uint256 safeId", "uint256 nearestSpotInLiquidationQueue"], "outputs": []}, {"name": "getInactiveDebtAndCollateral", "summary": "Retrieves the inactive debt and collateral amounts for a given Safe.", "inputs": ["uint256 safeId"], "outputs": ["uint256", "uint256"]}, {"name": "updateTokenURI", "summary": "Updates the token URI (Uniform Resource Identifier) for a specific token ID.", "inputs": ["uint256 tokenId", "string memory newTokenURI"], "outputs": []}, {"name": "_isApprovedOrOwner", "summary": "Checks if a given address is either the owner or an approved spender for a specific token ID (likely related to access control).", "inputs": ["address spender", "uint256 tokenId"], "outputs": []}], "is_deployable": true, "constructor": "constructor() StableBase() {}"}, {"name": "SBUtils", "type": "library", "summary": "The SBUtils library provides utility functions for managing safe IDs, depositing/withdrawing ETH or tokens, and handling compressed rates.", "functions": [{"name": "getSafeId", "summary": "Calculates a unique safe ID based on the borrower's address and the token's address.", "inputs": ["address _borrower", "address _token"], "outputs": ["uint256"]}, {"name": "depositEthOrToken", "summary": "Transfers either ETH or a specified token to the recipient.", "inputs": ["address _token", "address _to", "uint256 _amount"], "outputs": []}, {"name": "withdrawEthOrToken", "summary": "Withdraws either ETH or a specified token to the recipient.", "inputs": ["address _token", "address _to", "uint256 _amount"], "outputs": []}, {"name": "getRateAtPosition", "summary": "Retrieves a rate at a specific position from a compressed rate representation.", "inputs": ["uint256 _compressedRate", "uint256 _position"], "outputs": ["uint256"]}], "is_deployable": false, "constructor": "null"}, {"name": "SBStructs", "type": "library", "summary": "The contract named `SBStructs` is a library, which suggests that it provides a collection of utility functions or data structures for other contracts to use. Libraries are not meant to be deployed on their own, but rather linked to other contracts to enhance their functionality. Based on the provided data, it's designed to offer functionalities related to structs, likely for data manipulation or organization.", "functions": [], "is_deployable": false, "constructor": "null"}, {"name": "IMintableToken", "type": "interface", "summary": "The IMintableToken interface defines a standard for mintable tokens, allowing for the creation of new tokens and assigning them to specific addresses. It provides a single function, `mint`, to perform this action.", "functions": [{"name": "mint", "summary": "Mints new tokens and assigns them to the specified address.", "inputs": ["address to", "uint256 amount"], "outputs": ["bool"]}], "is_deployable": false, "constructor": "null"}, {"name": "IRewardSender", "type": "interface", "summary": "This contract defines an interface for managing reward distribution to the Stability Pool. It allows an authorized entity to enable or disable the Stability Pool's ability to receive rewards, likely as part of a larger reward distribution mechanism.", "functions": [{"name": "setCanStabilityPoolReceiveRewards", "summary": "Allows setting whether the Stability Pool can receive rewards. If `canReceiveRewards` is true, the Stability Pool is eligible to receive rewards. If `canReceiveRewards` is false, the Stability Pool will not receive rewards.", "inputs": ["bool canReceiveRewards"], "outputs": ["bool"]}], "is_deployable": false, "constructor": ""}, {"name": "StabilityPool", "type": "contract", "summary": "Allows users to stake tokens, earn rewards (SBR tokens and collateral), and participate in liquidations. Manages user stakes, reward distribution, and interactions with other contracts like StableBaseCDP. Allows adding rewards and performing liquidations.", "functions": [{"name": "setAddresses", "summary": "Sets the addresses for staking token, StableBaseCDP, and SBR token contracts.", "inputs": ["address _stakingToken", "address _stableBaseCDP", "address _sbrToken"], "outputs": []}, {"name": "stake", "summary": "Stakes tokens.", "inputs": ["uint256 _amount"], "outputs": []}, {"name": "unstake", "summary": "Unstakes tokens.", "inputs": ["uint256 amount"], "outputs": []}, {"name": "stake", "summary": "Stakes tokens through a frontend with a fee.", "inputs": ["uint256 _amount", "address frontend", "uint256 fee"], "outputs": []}, {"name": "unstake", "summary": "Unstakes tokens through a frontend with a fee.", "inputs": ["uint256 _amount", "address frontend", "uint256 fee"], "outputs": []}, {"name": "claim", "summary": "Claims rewards.", "inputs": [], "outputs": []}, {"name": "claim", "summary": "Claims rewards through a frontend with a fee.", "inputs": ["address frontend", "uint256 fee"], "outputs": []}, {"name": "addReward", "summary": "Adds reward tokens.", "inputs": ["uint256 _amount"], "outputs": ["bool"]}, {"name": "addCollateralReward", "summary": "Adds collateral reward.", "inputs": ["uint256 amount"], "outputs": ["bool"]}, {"name": "isLiquidationPossible", "summary": "Checks if a liquidation is possible.", "inputs": ["uint256 amount"], "outputs": []}, {"name": "performLiquidation", "summary": "Performs a liquidation.", "inputs": ["uint256 amount", "uint256 collateral"], "outputs": []}, {"name": "userPendingReward", "summary": "Retrieves pending reward for user.", "inputs": ["address _user"], "outputs": ["uint256"]}, {"name": "userPendingCollateral", "summary": "Retrieves pending collateral for user.", "inputs": ["address _user"], "outputs": ["uint256"]}, {"name": "userPendingRewardAndCollateral", "summary": "Retrieves pending reward and collateral for user.", "inputs": ["address _user"], "outputs": ["uint256", "uint256", "uint256"]}, {"name": "getUser", "summary": "Retrieves user information.", "inputs": ["address _user"], "outputs": ["UserInfo memory user"]}], "is_deployable": true, "constructor": "constructor(bool _rewardSenderActive) Ownable(msg.sender) {\n        rewardSenderActive = _rewardSenderActive;\n    }"}, {"name": "DFIDToken", "type": "contract", "summary": "This contract defines a token named 'D.FI Dollar' (DFID) and allows for minting and burning of tokens. It also sets up contract ownership using the Ownable contract and sets the stable base CDP address. The contract appears to be a standard ERC20 token with added administrative functionalities for minting and burning, thus it's deployable.", "functions": [{"name": "setAddresses", "summary": "Sets the address of the stable base CDP contract", "inputs": ["address _stableBaseCDP"], "outputs": []}, {"name": "mint", "summary": "Mints new tokens and sends them to the specified address", "inputs": ["address to", "uint256 amount"], "outputs": []}, {"name": "burn", "summary": "Burns tokens from the specified address", "inputs": ["address from", "uint256 amount"], "outputs": []}], "is_deployable": true, "constructor": "constructor() Ownable(msg.sender) ERC20(\"D.FI Dollar\", \"DFID\") {}"}, {"name": "IMintableToken", "type": "interface", "summary": "This interface defines the basic functionality for a mintable token, including the ability to mint new tokens and burn existing tokens. It is not deployable.", "functions": [{"name": "mint", "summary": "Mints new tokens and assigns them to a specified address.", "inputs": ["address to", "uint256 amount"], "outputs": ["bool"]}, {"name": "burn", "summary": "Burns (destroys) tokens from a specified address.", "inputs": ["address from", "uint256 amount"], "outputs": ["bool"]}], "is_deployable": false, "constructor": "null"}, {"name": "StableBase", "type": "abstract", "summary": "The StableBase contract is an abstract contract that serves as the foundation for managing safes (collateralized debt positions) within a stablecoin system. It provides functionalities for borrowing, redemption, liquidation, and fee distribution, while interacting with other key components like price oracles, stability pools, and staking pools. It inherits from Ownable and ERC721, indicating ownership management and NFT representation of safes.", "functions": [{"name": "setAddresses", "summary": "Sets the addresses of important contracts and components used by the StableBase contract. This function can only be called by the owner.", "inputs": ["address _sbdToken", "address _priceOracle", "address _stabilityPool", "address _dfireTokenStaking", "address _safesOrderedForLiquidation", "address _safesOrderedForRedemption"], "outputs": ["None"]}, {"name": "handleBorrow", "summary": "Handles the borrowing process for a given safe, taking into account various parameters such as the safe's ID, amount, shielding rate, and queue positions. This is likely an internal function.", "inputs": ["uint256 safeId", "Safe storage safe", "uint256 amount", "uint256 shieldingRate", "uint256 nearestSpotInLiquidationQueue", "uint256 nearestSpotInRedemptionQueue"], "outputs": ["None"]}, {"name": "min", "summary": "Returns the minimum of two unsigned integers. This is likely an internal helper function.", "inputs": ["uint256 a", "uint256 b"], "outputs": ["uint256"]}, {"name": "calculateRedemptionAmountsAndFee", "summary": "Calculates the amounts and fees associated with redeeming a safe, considering the safe's state, amount to redeem, and collateral price. This is a public function.", "inputs": ["Safe memory safe", "uint256 amountToRedeem", "uint256 collateralPrice"], "outputs": ["bool borrowMode", "uint256 _collateralToRedeem", "uint256 _amountToRedeem", "uint256 _amountToRefund", "uint256 _ownerFee", "uint256 _redeemerFee"]}, {"name": "_redeemNode", "summary": "Redeems a specific node (safe) based on the redemption details and its position in the liquidation queue. This is likely an internal function.", "inputs": ["uint256 _safeId", "SBStructs.Redemption memory redemption", "uint256 nearestSpotInLiquidationQueue"], "outputs": ["None"]}, {"name": "_redeemSafes", "summary": "Redeems multiple safes based on the redemption details and their positions in the liquidation queue. This is likely an internal function.", "inputs": ["SBStructs.Redemption memory redemption", "uint256 nearestSpotInLiquidationQueue"], "outputs": ["None"]}, {"name": "closeToZero", "summary": "Checks if a given value is close to zero. This is likely an internal helper function.", "inputs": ["uint256 value"], "outputs": ["bool"]}, {"name": "redeemSafe", "summary": "Redeems a safe with specific parameters, including the safe's ID, borrow mode, amounts to redeem/refund/return, and redemption details. This is likely an internal function.", "inputs": ["uint256 _safeId", "bool borrowMode", "uint256 amountToRedeem", "uint256 amountToRefund", "uint256 collateralToRedeem", "uint256 collateralToReturn", "Safe memory safe", "uint256 nearestSpotInLiquidationQueue", "SBStructs.Redemption memory redemption"], "outputs": ["None"]}, {"name": "_redeemToUser", "summary": "Redeems assets to a user based on the redemption details. This is likely an internal function.", "inputs": ["SBStructs.Redemption memory redemption"], "outputs": ["None"]}, {"name": "distributeFees", "summary": "Distributes fees associated with a safe, potentially minting new tokens based on the 'mint' flag. This is likely an internal function.", "inputs": ["uint256 safeId", "uint fee", "bool mint"], "outputs": ["None"]}, {"name": "distributeDebtAndCollateral", "summary": "Distributes debt and collateral amounts, considering the total collateral after liquidation. This is likely an internal function.", "inputs": ["uint256 debtAmount", "uint256 collateralAmount", "uint256 totalCollateralAfterLiquidation"], "outputs": ["None"]}, {"name": "_updateSafe", "summary": "Updates the details of a safe in storage. This is likely an internal function.", "inputs": ["uint _safeId", "Safe storage _safe"], "outputs": ["None"]}, {"name": "_updateTotalDebt", "summary": "Updates the total debt by adding or subtracting a delta value. This is likely an internal function.", "inputs": ["uint256 currentDebt", "uint256 delta", "bool add"], "outputs": ["None"]}, {"name": "_liquidate", "summary": "Liquidates a safe, starting the liquidation process with a given gas amount. This is likely an internal function.", "inputs": ["uint256 _safeId", "uint256 gasStart"], "outputs": ["None"]}, {"name": "_distributeLiquidationFeeAndGasCompensation", "summary": "Distributes the liquidation fee and gas compensation after a liquidation event. This is likely an internal function.", "inputs": ["uint256 safeId", "uint256 gasUsed", "uint256 liquidationFee", "uint256 refund"], "outputs": ["None"]}, {"name": "_removeSafe", "summary": "Removes a safe from the system. This is likely an internal function.", "inputs": ["uint256 _safeId"], "outputs": ["None"]}, {"name": "_removeSafeFromBothQueues", "summary": "Removes a safe from both the liquidation and redemption queues. This is likely an internal function.", "inputs": ["uint256 safeId"], "outputs": ["None"]}, {"name": "setCanStabilityPoolReceiveRewards", "summary": "Sets whether the stability pool can receive rewards. This function can only be called by the owner.", "inputs": ["bool canReceiveRewards"], "outputs": ["bool"]}, {"name": "setCanSBRStakingPoolReceiveRewards", "summary": "Sets whether the SBR staking pool can receive rewards. This function can only be called by the owner.", "inputs": ["bool canReceiveRewards"], "outputs": ["bool"]}], "is_deployable": false, "constructor": "constructor() Ownable(msg.sender) ERC721(\"StableBase Safe\", \"SBSafe\") {}"}, {"name": "Constants", "type": "contract", "summary": "The contract `Constants` likely serves to define and store constant values that can be used by other contracts. Since it has no constructor or functions, it probably just declares constant variables. This contract is deployable as the type is contract and there is no abstract specifier.", "functions": [], "is_deployable": true, "constructor": "null"}, {"name": "MockDebtContract", "type": "contract", "summary": "This contract simulates a debt contract, allowing setting a pool address, adding rewards, and liquidating debt. It interacts with a staking token (IERC20) for staking purposes. It provides functionalities to manage a debt pool and handle liquidations.", "functions": [{"name": "setPool", "summary": "Sets the pool address for the contract.", "inputs": ["address _pool"], "outputs": ["void"]}, {"name": "addReward", "summary": "Adds rewards to the contract.", "inputs": ["uint256 _amount"], "outputs": ["void"]}, {"name": "liquidate", "summary": "Liquidates a debt, taking an amount and collateral as input, and returning a uint256.", "inputs": ["uint256 amount", "uint256 collateral"], "outputs": ["uint256"]}], "is_deployable": true, "constructor": "constructor(address _stakingToken) {\n        stakingToken = IERC20(_stakingToken);\n    }"}, {"name": "IRewardSender", "type": "interface", "summary": "The IRewardSender interface defines a function to control whether a specific staking pool is allowed to receive rewards. It likely manages the distribution of reward tokens to different staking pools within a larger decentralized finance (DeFi) system.", "functions": [{"name": "setCanSBRStakingPoolReceiveRewards", "summary": "This function allows an authorized entity to enable or disable a specific SBR (Staked Balance Reward) staking pool from receiving rewards. This could be used to temporarily halt rewards for a pool due to maintenance, security concerns, or changes in reward distribution strategy. The function returns a boolean indicating whether the operation was successful.", "inputs": ["bool canReceiveRewards"], "outputs": ["bool"]}], "is_deployable": false, "constructor": "null"}, {"name": "DFIREStaking", "type": "contract", "summary": "The DFIREStaking contract enables users to stake tokens and earn rewards. It offers functions for setting up the contract with appropriate tokens, staking and unstaking tokens, adding rewards, and claiming rewards. The contract inherits from Ownable, providing access control for sensitive functions, such as adding rewards and configuring the contract.", "functions": [{"name": "setAddresses", "summary": "Sets the addresses for the staking token, reward token, and stable base contract. This function likely needs to be called after deployment to configure the contract properly. This function is intended to be called once to configure the contract's core parameters with correct address", "inputs": ["address _stakingToken", "address _rewardToken", "address _stableBaseContract"], "outputs": []}, {"name": "stake", "summary": "Allows users to stake a specified amount of staking tokens in the contract. The amount must be greater than zero, and the contract must be properly initialized with staking token", "inputs": ["uint256 _amount"], "outputs": []}, {"name": "unstake", "summary": "Allows users to unstake a specified amount of their staked tokens from the contract. It checks if the user has sufficient staked tokens to unstake", "inputs": ["uint256 _amount"], "outputs": []}, {"name": "addReward", "summary": "Allows the owner to add reward tokens to the contract for distribution to stakers. It transfers the reward tokens from the message sender to the contract, and the message sender must be the owner", "inputs": ["uint256 _amount"], "outputs": ["bool"]}, {"name": "addCollateralReward", "summary": "Allows the owner to add collateral reward tokens to the contract for distribution to stakers, which is different than the base reward.  It transfers collateral reward tokens from the message sender to the contract, and the sender must be the owner", "inputs": ["uint256 _amount"], "outputs": ["bool"]}, {"name": "_claim", "summary": "Internal function to handle the claiming of rewards for a given user. Not directly callable by external users. This function calculates the reward and transfers it to the user", "inputs": ["Stake storage user"], "outputs": []}, {"name": "claim", "summary": "Allows users to claim their accumulated rewards. This function calls the internal _claim function to handle the reward calculation and transfer", "inputs": [], "outputs": []}, {"name": "getStake", "summary": "Returns the stake information (amount, timestamp, etc.) for a given user. It returns the details of a user's stake, allowing other contracts to query stake information", "inputs": ["address user"], "outputs": ["Stake Information"]}, {"name": "userPendingReward", "summary": "Returns the amount of pending rewards for a given user. It calculates the pending reward a user has accumulated based on their stake and contract parameters", "inputs": ["address user"], "outputs": ["uint256"]}], "is_deployable": true, "constructor": "constructor(bool _rewardSenderActive) Ownable(msg.sender) {\n        rewardSenderActive = _rewardSenderActive;\n    }"}, {"name": "DFIREToken", "type": "contract", "summary": "The DFIREToken contract is an ERC20 token with minting and burning functionalities controlled by the owner. It also includes a function to set the address of a stability pool contract.", "functions": [{"name": "setAddresses", "summary": "Sets the address of the stability pool contract. Callable by the owner.", "inputs": ["address _stabilityPool"], "outputs": ["No return value"]}, {"name": "mint", "summary": "Mints new tokens and sends them to the specified address. Callable by the owner.", "inputs": ["address to", "uint256 amount"], "outputs": ["No return value"]}, {"name": "burn", "summary": "Burns tokens from the specified address. Callable by the owner.", "inputs": ["address from", "uint256 amount"], "outputs": ["No return value"]}], "is_deployable": true, "constructor": "constructor() Ownable(msg.sender) ERC20(\"D.FIRE\", \"DFIRE\") { Initializes the contract, setting the deployer as the owner and initializing the ERC20 token with the name \"D.FIRE\" and symbol \"DFIRE\". }"}, {"name": "ReenterStabilityPool", "type": "contract", "summary": "This contract, named ReenterStabilityPool, serves as a *testing* and *demonstration* contract to illustrate potential reentrancy vulnerabilities when interacting with a StabilityPool contract (specified by `_stabilityPool` in the constructor) and a stake token (an ERC20 token specified by `_stakeToken` in the constructor). It provides functions (stake1, stake2, unstake, and claim) that, when called, are designed to trigger reentrancy attacks on the StabilityPool contract by calling back into it during their execution. The `_reenterFunction` parameter in each function specifies which function in the StabilityPool should be re-entered.", "functions": [{"name": "stake1", "summary": "The stake1 function allows an external user to call the stability pool contract with reentrancy conditions. The `_reenterFunction` parameter determines which function in the StabilityPool will be re-entered.", "inputs": ["uint256 _reenterFunction"], "outputs": []}, {"name": "stake2", "summary": "The stake2 function allows an external user to call the stability pool contract with reentrancy conditions and a specified amount. The `_reenterFunction` parameter determines which function in the StabilityPool will be re-entered.", "inputs": ["uint256 _reenterFunction", "uint256 amount"], "outputs": []}, {"name": "unstake", "summary": "The unstake function allows an external user to call the stability pool contract with reentrancy conditions. The `_reenterFunction` parameter determines which function in the StabilityPool will be re-entered.", "inputs": ["uint256 _reenterFunction"], "outputs": []}, {"name": "claim", "summary": "The claim function allows an external user to call the stability pool contract with reentrancy conditions. The `_reenterFunction` parameter determines which function in the StabilityPool will be re-entered.", "inputs": ["uint256 _reenterFunction"], "outputs": []}], "is_deployable": true, "constructor": "constructor(address _stabilityPool, address _stakeToken) {\n        stabilityPool = IStabilityPool(_stabilityPool);\n        stakeToken = IERC20(_stakeToken);\n    }"}, {"name": "ReenterDfireStaking", "type": "contract", "summary": "This contract, named 'ReenterDfireStaking', interacts with a DFIREStaking contract to allow users to stake, unstake, and claim rewards. The contract appears to be designed to test or exploit reentrancy vulnerabilities within the DFIREStaking contract. The functions stake1, stake2, unstake, and claim each take a _reenterFunction parameter, suggesting a mechanism to control or trigger reentrancy.", "functions": [{"name": "stake1", "summary": "This function allows to stake tokens, potentially reentering the DFIREStaking contract based on _reenterFunction value.", "inputs": ["uint256 _reenterFunction"], "outputs": []}, {"name": "stake2", "summary": "This function allows to stake a specified amount of tokens, potentially reentering the DFIREStaking contract based on _reenterFunction value.", "inputs": ["uint256 _reenterFunction", "uint256 amount"], "outputs": []}, {"name": "unstake", "summary": "This function allows to unstake tokens, potentially reentering the DFIREStaking contract based on _reenterFunction value.", "inputs": ["uint256 _reenterFunction"], "outputs": []}, {"name": "claim", "summary": "This function allows to claim rewards, potentially reentering the DFIREStaking contract based on _reenterFunction value.", "inputs": ["uint256 _reenterFunction"], "outputs": []}], "is_deployable": true, "constructor": "constructor(address _dfireStaking, address _dfireStakingToken) {\n        dfireStaking = IDFIREStaking(_dfireStaking);\n        stakeToken = IERC20(_dfireStakingToken);\n    }"}, {"name": "TestMath", "type": "contract", "summary": "The TestMath contract allows adding and subtracting weighted values and then calculates a rate based on the accumulated values and weights. It is deployable because its type is 'contract'.", "functions": [{"name": "addValue", "summary": "Adds a value multiplied by a weight to an internal accumulator.", "inputs": ["uint256 value", "uint256 weight"], "outputs": ["None"]}, {"name": "subtractValue", "summary": "Subtracts a value multiplied by a weight from an internal accumulator.", "inputs": ["uint256 value", "uint256 weight"], "outputs": ["None"]}, {"name": "calculateRate", "summary": "Calculates a rate based on the accumulated added and subtracted values and their corresponding weights. The exact calculation logic is not specified, requiring further analysis of the contract's implementation.", "inputs": [], "outputs": ["uint256"]}], "is_deployable": true, "constructor": "null"}, {"name": "OrderedDoublyLinkedList", "type": "contract", "summary": "The `OrderedDoublyLinkedList` contract implements an ordered doubly linked list data structure. It allows insertion, removal, and retrieval of nodes based on their ID. The contract maintains a head and tail pointer to enable efficient traversal. The contract also includes functions to retrieve nodes by ID or in batches. It inherits from Ownable, meaning it has an owner who can likely manage certain aspects of the contract.", "functions": [{"name": "setAddresses", "summary": "Potentially sets the address of a stable base CDP, indicating interaction with another contract.  The specific use isn't clear without further context.", "inputs": ["address _stableBaseCDP"], "outputs": []}, {"name": "_insert", "summary": "Internal function to insert a new node with a given ID and node data into the linked list, using `_nearestSpot` as a hint for insertion location. Node parameter is a struct with previous and next pointers and value.", "inputs": ["uint256 id", "Node memory node", "uint256 _nearestSpot"], "outputs": []}, {"name": "_insert", "summary": "Internal function to insert a new node with a given ID and value into the linked list, using `_nearestSpot` as a hint for insertion location.", "inputs": ["uint256 id", "uint256 value", "uint256 _nearestSpot"], "outputs": []}, {"name": "_remove", "summary": "Internal function to remove a node from the linked list based on its ID.", "inputs": ["uint256 id"], "outputs": []}, {"name": "_update", "summary": "Internal function to update the value of a node in the linked list, using `_nearestSpot` as a hint.", "inputs": ["uint256 id", "uint256 value", "uint256 _nearestSpot"], "outputs": []}, {"name": "upsert", "summary": "External function to insert or update a node in the linked list. If the node with the given ID exists, its value is updated. Otherwise, a new node is inserted, using `_nearestSpot` as a hint.", "inputs": ["uint256 id", "uint256 value", "uint256 _nearestSpot"], "outputs": []}, {"name": "remove", "summary": "External function to remove a node from the linked list based on its ID.", "inputs": ["uint256 id"], "outputs": []}, {"name": "get", "summary": "External function to retrieve a node (Node memory) from the linked list based on its ID.", "inputs": ["uint256 id"], "outputs": ["Node memory"]}, {"name": "getHead", "summary": "External function to retrieve the ID of the head node in the linked list.", "inputs": [], "outputs": ["uint256"]}, {"name": "getTail", "summary": "External function to retrieve the ID of the tail node in the linked list.", "inputs": [], "outputs": ["uint256"]}, {"name": "getNode", "summary": "Public function to retrieve the node from the linked list based on its ID.", "inputs": ["uint256 id"], "outputs": ["Node memory"]}, {"name": "getNodes", "summary": "External function to retrieve a batch of nodes from the linked list, starting at `beginAt` and retrieving up to `total` nodes. Returns an array of nodes and the total number of nodes found.", "inputs": ["uint256 beginAt", "uint256 total"], "outputs": ["Node[50] memory n, uint256 totalFound"]}], "is_deployable": true, "constructor": "constructor() Ownable(msg.sender) {\n        head = 0;\n        tail = 0;\n    }"}, {"name": "Math", "type": "library", "summary": "The Math library provides mathematical functions, including rate calculations, weighted additions and subtractions, zero checks, shielding hour calculations, and time conversions.", "functions": [{"name": "calculateRate", "summary": "Calculates a rate.", "inputs": ["Rate rate"], "outputs": []}, {"name": "add", "summary": "Adds a weighted value to a rate.", "inputs": ["Rate rate", "uint256 value", "uint256 weight"], "outputs": []}, {"name": "subtract", "summary": "Subtracts a weighted value from a rate.", "inputs": ["Rate rate", "uint256 value", "uint256 weight"], "outputs": []}, {"name": "isZero", "summary": "Checks if a rate is zero.", "inputs": ["Rate rate"], "outputs": []}, {"name": "getShieldingHours", "summary": "Calculates shielding hours.", "inputs": ["Rate referenceRate", "uint256 currentRate"], "outputs": []}, {"name": "toSeconds", "summary": "Converts hours to seconds.", "inputs": ["uint256 hours_"], "outputs": []}], "is_deployable": false, "constructor": "null"}, {"name": "RateLib", "type": "library", "summary": "This library provides functions for calculating, adding to, subtracting from, and checking if a rate is zero, based on a Math.Rate struct. It's designed to manage rate calculations within a smart contract.", "functions": [{"name": "calculateRate", "summary": "Calculates a rate based on the provided Math.Rate struct.", "inputs": ["Math.Rate memory rate"], "outputs": []}, {"name": "add", "summary": "Adds a weighted value to the provided Math.Rate struct.", "inputs": ["Math.Rate memory rate", "uint256 value", "uint256 weight"], "outputs": []}, {"name": "subtract", "summary": "Subtracts a weighted value from the provided Math.Rate struct.", "inputs": ["Math.Rate memory rate", "uint256 value", "uint256 weight"], "outputs": []}, {"name": "isZero", "summary": "Checks if the provided Math.Rate struct is zero.", "inputs": ["Math.Rate memory rate"], "outputs": []}], "is_deployable": false, "constructor": "null"}, {"name": "IPriceOracle", "type": "interface", "summary": "Defines a price oracle interface for accessing price feeds.", "functions": [{"name": "lastGoodPrice", "summary": "Returns the last known good price.", "inputs": [], "outputs": ["uint256"]}, {"name": "fetchPrice", "summary": "Fetches the latest price.", "inputs": [], "outputs": ["uint256"]}], "is_deployable": false, "constructor": "null"}, {"name": "IDoublyLinkedList", "type": "interface", "summary": "This contract defines the interface for a doubly linked list data structure. It provides functions to add, remove, get, and update nodes in the list, as well as functions to retrieve the head and tail of the list. Since it is an interface, it cannot be deployed directly.", "functions": [{"name": "remove", "summary": "Removes a node from the doubly linked list by its ID.", "inputs": ["uint256 id"], "outputs": ["Node memory"]}, {"name": "get", "summary": "Retrieves a node from the doubly linked list by its ID.", "inputs": ["uint256 id"], "outputs": ["Node memory"]}, {"name": "upsert", "summary": "Inserts or updates a node in the doubly linked list. If a node with the given ID exists, it updates the value; otherwise, it inserts a new node near the specified spot.", "inputs": ["uint256 id", "uint256 value", "uint256 _nearestSpot"], "outputs": ["Node memory"]}, {"name": "getHead", "summary": "Retrieves the ID of the head (first node) of the doubly linked list.", "inputs": [], "outputs": ["uint256"]}, {"name": "getTail", "summary": "Retrieves the ID of the tail (last node) of the doubly linked list.", "inputs": [], "outputs": ["uint256"]}], "is_deployable": false, "constructor": "null"}, {"name": "IReservePool", "type": "interface", "summary": "The `IReservePool` interface defines the functions for managing stake in a reserve pool. It enables users to add stake to a specific ID, retrieve the stake amount for an ID, and remove stake (either a specific amount or all stake) from an ID.", "functions": [{"name": "addStake", "summary": "Adds stake to a specific ID.", "inputs": ["uint256 id", "uint256 amount"], "outputs": ["None"]}, {"name": "getStake", "summary": "Retrieves the stake for a specific ID.", "inputs": ["uint256 id"], "outputs": ["uint256"]}, {"name": "removeStake", "summary": "Removes a specified amount of stake from a specific ID.", "inputs": ["uint256 id", "uint256 amount"], "outputs": ["bool", "uint256"]}, {"name": "removeStake", "summary": "Removes all stake from a specific ID.", "inputs": ["uint256 id"], "outputs": ["bool", "uint256"]}], "is_deployable": false, "constructor": "null"}, {"name": "IStabilityPool", "type": "interface", "summary": "The IStabilityPool interface defines the functions for interacting with a stability pool. The pool allows users to stake and unstake tokens, claim rewards, liquidate positions, and add rewards. It also provides functions for querying user information and pending rewards.", "functions": [{"name": "stake", "summary": "Stake tokens to the pool.", "inputs": ["uint256 _amount"], "outputs": []}, {"name": "stake", "summary": "Stake tokens to the pool with frontend referral and fee.", "inputs": ["uint256 _amount", "address _frontend", "uint256 fee"], "outputs": []}, {"name": "unstake", "summary": "Unstake tokens from the pool.", "inputs": ["uint256 _amount"], "outputs": []}, {"name": "unstake", "summary": "Unstake tokens from the pool with frontend referral and fee.", "inputs": ["uint256 _amount", "address _frontend", "uint256 fee"], "outputs": []}, {"name": "claim", "summary": "Claim accumulated rewards.", "inputs": [], "outputs": []}, {"name": "claim", "summary": "Claim accumulated rewards with frontend referral and fee.", "inputs": ["address _frontend", "uint256 fee"], "outputs": []}, {"name": "isLiquidationPossible", "summary": "Check if liquidation is possible for a given amount.", "inputs": ["uint256 amount"], "outputs": ["bool"]}, {"name": "performLiquidation", "summary": "Perform liquidation with specified amount and collateral.", "inputs": ["uint256 amount", "uint256 collateral"], "outputs": ["bool"]}, {"name": "addReward", "summary": "Add rewards to the pool.", "inputs": ["uint256 _amount"], "outputs": ["bool"]}, {"name": "addCollateralReward", "summary": "Add collateral rewards to the pool.", "inputs": ["uint256 _amount"], "outputs": ["bool"]}, {"name": "getUser", "summary": "Get user information.", "inputs": ["address user"], "outputs": ["UserInfo memory userInfo"]}, {"name": "userPendingReward", "summary": "Get user's pending reward.", "inputs": ["address user"], "outputs": ["uint256"]}, {"name": "userPendingCollateral", "summary": "Get user's pending collateral reward.", "inputs": ["address user"], "outputs": ["uint256"]}], "is_deployable": false, "constructor": "N/A"}, {"name": "IStableBase", "type": "interface", "summary": "The `IStableBase` interface defines the core functionalities for interacting with a stablecoin system. It includes functions for opening and closing collateralized debt positions (CDPs, referred to as 'Safes'), borrowing, repaying, adding and withdrawing collateral, redeeming stablecoins, topping up fees, liquidating positions, and managing rewards distribution to stability pools and staking pools. It does not specify the implementation details, but outlines the expected behavior of a contract implementing this interface.", "functions": [{"name": "openSafe", "summary": "Opens a new Safe (CDP) with a specified ID and collateral amount.", "inputs": ["uint256 _safeId", "uint256 _amount"], "outputs": []}, {"name": "closeSafe", "summary": "Closes an existing Safe (CDP) with a specified ID.", "inputs": ["uint256 _safeId"], "outputs": []}, {"name": "borrow", "summary": "Borrows a specified amount of stablecoins against a Safe (CDP).", "inputs": ["uint256 safeId", "uint256 amount", "uint256 shieldingRate", "uint256 nearestSpotInLiquidationQueue", "uint256 nearestSpotInRedemptionQueue"], "outputs": []}, {"name": "repay", "summary": "Repays a specified amount of borrowed stablecoins to a Safe (CDP).", "inputs": ["uint256 safeId", "uint256 amount", "uint256 nearestSpotInLiquidationQueue"], "outputs": []}, {"name": "addCollateral", "summary": "Adds collateral to an existing Safe (CDP).", "inputs": ["uint256 safeId", "uint256 amount", "uint256 nearestSpotInLiquidationQueue"], "outputs": []}, {"name": "withdrawCollateral", "summary": "Withdraws collateral from an existing Safe (CDP).", "inputs": ["uint256 safeId", "uint256 amount", "uint256 nearestSpotInLiquidationQueue"], "outputs": []}, {"name": "redeem", "summary": "Redeems a specified amount of stablecoins.", "inputs": ["uint256 _amount", "uint256 nearestSpotInLiquidationQueue"], "outputs": []}, {"name": "feeTopup", "summary": "Tops up the fee for a Safe (CDP).", "inputs": ["uint256 safeId", "uint256 topupRate", "uint256 nearestSpotInRedemptionQueue"], "outputs": []}, {"name": "liquidate", "summary": "Liquidates undercollateralized Safes (CDPs).", "inputs": [], "outputs": []}, {"name": "getInactiveDebtAndCollateral", "summary": "Retrieves the inactive debt and collateral amounts for a Safe (CDP).", "inputs": ["uint256 safeId"], "outputs": ["uint256, uint256"]}, {"name": "setCanStabilityPoolReceiveRewards", "summary": "Sets whether the stability pool can receive rewards.", "inputs": ["bool canReceiveRewards"], "outputs": ["bool"]}, {"name": "setCanSBRStakingPoolReceiveRewards", "summary": "Sets whether the SBR staking pool can receive rewards.", "inputs": ["bool canReceiveRewards"], "outputs": ["bool"]}], "is_deployable": false, "constructor": ""}, {"name": "IRateGovernors", "type": "interface", "summary": "The IRateGovernors interface manages staking, reserve ratios, and target shielding rates. It allows adding and removing stake for specific IDs, updating the reserve ratio and target shielding rate, and redeeming. The exact nature of 'shielding' and 'redeeming' is not specified in this interface.", "functions": [{"name": "updateTargetShieldingRate", "summary": "Updates the target shielding rate for a specific ID.", "inputs": ["uint256 id", "uint256 _targetShieldingRate"], "outputs": []}, {"name": "updateReserveRatio", "summary": "Updates the reserve ratio.", "inputs": ["uint256 _reserveRatio"], "outputs": []}, {"name": "redeem", "summary": "Redeems something related to RateGovernors (details unspecified).", "inputs": [], "outputs": []}, {"name": "addStake", "summary": "Adds a stake for a specific ID with a given amount.", "inputs": ["uint256 id", "uint256 amount"], "outputs": []}, {"name": "getStake", "summary": "Retrieves the stake for a specific ID.", "inputs": ["uint256 id"], "outputs": ["uint256"]}, {"name": "removeStake", "summary": "Removes a specified amount of stake for a given ID.", "inputs": ["uint256 id", "uint256 amount"], "outputs": ["bool", "uint256"]}, {"name": "removeStake", "summary": "Removes stake for a given ID.", "inputs": ["uint256 id"], "outputs": ["bool", "uint256"]}], "is_deployable": false, "constructor": "null"}, {"name": "IDFIREStaking", "type": "interface", "summary": "The IDFIREStaking interface defines the functions for staking, unstaking, claiming rewards, and adding rewards within the IDFIRE staking system. It allows users to stake tokens, unstake tokens, claim accumulated rewards, and enables the contract owner to add rewards to the staking pool and collateral reward pool. It also provides functions to retrieve a user's stake information and pending rewards.", "functions": [{"name": "stake", "summary": "Allows a user to stake a specified amount of tokens.", "inputs": ["uint256 _amount"], "outputs": ["None"]}, {"name": "unstake", "summary": "Allows a user to unstake a specified amount of tokens.", "inputs": ["uint256 _amount"], "outputs": ["None"]}, {"name": "claim", "summary": "Allows a user to claim their accumulated rewards.", "inputs": [], "outputs": ["None"]}, {"name": "addReward", "summary": "Allows the contract owner to add rewards to the staking pool.", "inputs": ["uint256 _amount"], "outputs": ["bool"]}, {"name": "addCollateralReward", "summary": "Allows the contract owner to add rewards to the collateral reward pool.", "inputs": ["uint256 _amount"], "outputs": ["bool"]}, {"name": "getStake", "summary": "Returns the stake information for a given user.", "inputs": ["address user"], "outputs": ["Stake memory stake"]}, {"name": "userPendingReward", "summary": "Returns the pending rewards for a given user.", "inputs": ["address user"], "outputs": ["uint256, uint256"]}], "is_deployable": false, "constructor": "None"}, {"name": "IStableBaseCDP", "type": "interface", "summary": "The IStableBaseCDP interface defines the functions for interacting with a Stablecoin CDP (Collateralized Debt Position) system. It allows users to open, close, borrow from, repay to, and manage their CDPs. It also includes functions for liquidation, updating reserve ratios and origination fees, and setting reward receiving capabilities for stability pools and SBR staking.", "functions": [{"name": "openSafe", "summary": "Opens a new CDP (Safe) with specified collateral token, amount, reserve ratio, and position in reserve.", "inputs": ["address collateralToken", "uint256 amount", "uint256 reserveRatio", "uint256 positionInReserve"], "outputs": []}, {"name": "closeSafe", "summary": "Closes an existing CDP (Safe) for a given collateral token.", "inputs": ["address collateralToken"], "outputs": []}, {"name": "borrow", "summary": "Borrows a specified amount against a collateral token.", "inputs": ["address collateralToken", "uint256 amount"], "outputs": []}, {"name": "repay", "summary": "Repays a borrowed amount for a given collateral token.", "inputs": ["address collateralToken", "uint256 amount"], "outputs": []}, {"name": "withdrawCollateral", "summary": "Withdraws a specified amount of collateral for a given collateral token.", "inputs": ["address collateralToken", "uint256 amount"], "outputs": []}, {"name": "redeem", "summary": "Redeems a specified amount.", "inputs": ["uint256 amount"], "outputs": []}, {"name": "liquidate", "summary": "Liquidates a CDP (Safe) with a given ID.", "inputs": ["uint256 id"], "outputs": []}, {"name": "repayAndLiquidate", "summary": "Repays debt and liquidates a CDP (Safe) with a given ID.", "inputs": ["uint256 id"], "outputs": []}, {"name": "updateReserveRatio", "summary": "Updates the reserve ratio and position in reserve for a given collateral token.", "inputs": ["address collateralToken", "uint256 newReserveRatio", "uint256 newPositionInReserve"], "outputs": []}, {"name": "updateOriginationFee", "summary": "Updates the origination fee for a given collateral token.", "inputs": ["address collateralToken", "uint256 newOriginationFee"], "outputs": []}, {"name": "setStabilityPoolCanReceiveRewards", "summary": "Sets whether the stability pool can receive rewards.", "inputs": ["bool canReceiveRewards"], "outputs": []}, {"name": "setSBRStakingCanReceiveRewards", "summary": "Sets whether SBR staking can receive rewards.", "inputs": ["bool canReceiveRewards"], "outputs": []}], "is_deployable": false, "constructor": "null"}, {"name": "ChainlinkPriceFeed", "type": "contract", "summary": "The contract `ChainlinkPriceFeed` is designed to fetch the latest price of an asset from a Chainlink price feed. It initializes the appropriate AggregatorV3Interface based on the chain ID provided during deployment. The `fetchPrice` function retrieves the latest price from the Chainlink oracle, while `lastGoodPrice` retrieves the last known good price.", "functions": [{"name": "lastGoodPrice", "summary": "Retrieves the last known good price from the Chainlink oracle.", "inputs": [], "outputs": []}, {"name": "fetchPrice", "summary": "Fetches the latest price from the Chainlink oracle.", "inputs": [], "outputs": ["uint256"]}], "is_deployable": true, "constructor": "constructor(uint256 chainId) {\n        if (chainId == 1) {\n            // Ethereum Mainnet\n            priceFeed = AggregatorV3Interface(\n                0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n            );\n        } else if (chainId == 11155111) {\n            // Sepolia Testnet\n            priceFeed = AggregatorV3Interface(\n                0x694AA1769357215DE4FAC081bf1f309aDC325306\n            );\n        } else if (chainId == 5) {\n            // Goerli Testnet (if needed)\n            priceFeed = AggregatorV3Interface(\n                0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e\n            );\n        } else {\n            revert(\"Unsupported chain ID\");\n        }\n    }"}, {"name": "MockPriceOracle", "type": "contract", "summary": "This contract is a mock price oracle that allows setting and fetching prices. It also stores the last good price. The constructor inherits from Ownable, setting the deployer as the owner.", "functions": [{"name": "setPrice", "summary": "Sets the price in the oracle.", "inputs": ["uint256 _price"], "outputs": []}, {"name": "lastGoodPrice", "summary": "Returns the last good price.", "inputs": [], "outputs": ["uint256"]}, {"name": "fetchPrice", "summary": "Returns the current price.", "inputs": [], "outputs": ["uint256"]}], "is_deployable": true, "constructor": "constructor() Ownable(msg.sender) {}"}]}